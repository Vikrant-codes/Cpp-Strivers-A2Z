<-- Iterators -->

Que â“What are iterators ?
ğŸ”¹An iterator is an object that allows you to traverse a container (like arrays, vectors, lists, etc.) element by element. It acts like a pointer 
and provides access to container elements without exposing the underlying structure.
ğŸ”¹It provides an abstraction for accessing elements in a container sequentially, but it is not necessarily a raw memory address. It behaves like 
a pointer but can be more complex, depending on the container.
ğŸ”¹It is not exactly a reference or a raw memory address, but it behaves like a pointer. It abstracts access to elements inside a container.
ğŸ”¹It can be dereferenced (*it) like a pointer to access elements.
ğŸ”¹It can be incremented/decremented (++it, --it) like a pointer.
ğŸ”¹However, it's not necessarily a memory address, as containers like map & list use iterators to traverse elements without guaranteeing contiguous storage.

Internally, an iterator can be:
ğŸ”¹A pointer (for contiguous containers like vector or array).
Example: vector<int>::iterator often behaves like int*.
ğŸ”¹A wrapper around a pointer (for non-contiguous containers like list or map).
Example: list<int>::iterator internally stores a pointer to a node in a linked list.
ğŸ”¹A class with overloaded operators that manages access to elements.  âœ…

Que â“Why can we perform arithmetic operations on iterators of vector,deque and arrays ?
Arithmetic operations like += are valid for random-access iterators, which are supported by containers such as vector, deque, and array.  âœ…

Que â“What's the difference between vector iterators (random-access iterators) and set/multiset iterators (bidirectional iterators) ?
The difference between vector iterators and set or multiset iterators lies in the type of iterator they provide and the operations that are supported 
by these iterators.

> Vector Iterators : vector iterators are random-access iterators. This means they support a wide range of operations, including:
ğŸ”¹Increment (++) and decrement (--)
ğŸ”¹Addition and subtraction of an integer (it + n, it - n)
ğŸ”¹Compound assignment (+=, -=)
ğŸ”¹Comparison (<, <=, >, >=)
ğŸ”¹Difference between two iterators (it2 - it1)
These operations are possible because vector elements are stored in contiguous memory locations, allowing direct access to any element by calculating 
its address.

> Set and Multiset Iterators : These are bidirectional iterators. They support a more limited set of operations compared to random-access iterators:
ğŸ”¹Increment (++) and decrement (--)
ğŸ”¹Comparison for equality (==, !=)
These iterators do not support arithmetic operations like addition or subtraction because set and multiset elements are not stored in contiguous 
memory locations. Instead, they are typically stored in a balanced tree structure, which allows efficient insertion, deletion, and lookup but does 
not allow direct access to elements by index. âœ…

Que â“How to advance bidirectional iterators as direct arithmetic operations are not possible on them ?
To advance iterators to certain position forward or backward, we can use two functions : std::advance() and std::next()
Syntax : std::advance(iterator, position) -> +ve position moves the iteartor forward while -ve moves backward. Same syntax is used for std::next()

1ï¸âƒ£ std::advance : It is part of the <iterator> header and can be used to move an iterator forward or backward by a specified number of positions.
ğŸ”¹It modifies the given iterator to move it forward or backward by a specified number of positions.
2ï¸âƒ£ std::next : It is a useful utility for advancing iterators. It is part of the <iterator> header and can be used to obtain an iterator that is a 
specified number of positions ahead of a given iterator. This function works with all types of iterators, including bidirectional & random-access iterators.
ğŸ”¹It returns a new iterator that is a specified number of positions ahead of the given iterator without modifying the original iterator. âœ…

<-- Pairs -->

Que â“How make_pair() Helps Create Pairs Quickly?
make_pair() automatically deduces the data types of the pair elements, making code cleaner and reducing the need for explicit type specification.
Consider the below code for example :-
auto p = make_pair(1, "Alice");  // Type is automatically deduced
cout << p.first << " " << p.second << endl;   âœ…

<-- Vectors -->

Que â“Difference between push_back() and emplace_back() in C++ Vectors.
Both push_back() and emplace_back() are used to add elements to a vector, but emplace_back() is faster in certain cases.
ğŸ”¹push_back() (Uses Copy/Move Constructor)
Creates a temporary object first and then copies/moves it into the vector.
More overhead when dealing with complex objects.

ğŸ”¹emplace_back() (Constructs In-Place)
Constructs the object directly inside the vector (no temporary object).
Avoids unnecessary copies/moves, making it more efficient.  âœ…

Que â“When to Use What?
Use push_back() if you already have an existing object.
Use emplace_back() if you're creating a new object, as it's faster and avoids extra overhead.  âœ…

Que â“Time Complexity of Insert operation in vectors. 
Time Complexity -->
ğŸ”¹Insert at end (push_back())	O(1) (Amortized)
ğŸ”¹Insert at beginning or middle	O(N) (Shifts elements)  âœ…

Que â“When to use push_back / insert ?
ğŸ”¹Use push_back() if inserting at the end (fastest).
ğŸ”¹Use insert() only when position matters.

Que â“Why Is emplace() More Efficient Than insert() ?
1ï¸âƒ£ insert() (Creates Temporary Object)
ğŸ”¹When you use insert(), it first constructs an object separately, then copies/moves it into the vector.
ğŸ”¹This adds extra overhead for complex objects.
2ï¸âƒ£ emplace() (Constructs In-Place)
ğŸ”¹emplace() constructs the object directly in the vectorâ€™s memory, avoiding extra copies/moves.
ğŸ”¹More efficient, especially for complex objects.    âœ…

Que â“Can emplace() Replace insert() Completely?
emplace() can perform all types of insertions like insert(), but it only works when constructing new objects in place.
ğŸ“Œ When emplace() is better?
ğŸ”¹When inserting a single new object at a specific position.
ğŸ”¹When inserting complex objects (avoids extra copies/moves).

ğŸ“Œ When insert() is required?
ğŸ”¹When inserting multiple elements at once.
ğŸ”¹When inserting a range from another container.

1ï¸âƒ£ Inserting a Single Element : Both insert() and emplace() work fine here.
2ï¸âƒ£ Inserting Multiple Copies (n copies) : âœ… Works with insert(), but emplace() does NOT support this.
3ï¸âƒ£ Inserting a Range (Another Vector, List, etc.) : âœ… Works with insert(), but emplace() does NOT support ranges.

4ï¸âƒ£ Inserting Complex Objects (Best for emplace()) : For objects like pair or classes, emplace() is more efficient. ex ->
vector<pair<int, string>> v;
v.insert(v.begin(), make_pair(1, "Alice"));
v.emplace(v.begin(), 1, "Alice");  // Directly constructs in-place

ğŸ”¹ Conclusion: When to Use What?
Operation	                    Use insert()	     Use emplace()
Insert a single element	        âœ… Works	            âœ… More efficient
Insert multiple copies	        âœ… Yes	            âŒ Not supported
Insert range of elements	    âœ… Yes	            âŒ Not supported
Insert complex objects	        âœ… Works	            âœ… More efficient

<< Use emplace() when inserting one new object (best for complex types). Use insert() for multiple copies or inserting a range. >>   âœ…

Que â“Explain upper_bound and lower_bound functions in vectors (also used in other containers like set, map , multiset) ?
ğŸ”¹lower_bound() and upper_bound() functions are available in ordered containers like vector, set, map or multiset.
ğŸ”¹These functions are used to perform binary search in sorted vectors or other containers efficiently.
1ï¸âƒ£ lower_bound() : Finds the first element that is greater than or equal to a given value.
2ï¸âƒ£ upper_bound() : Finds the first element that is strictly greater than the given value.
3ï¸âƒ£ Practical Use Case: Count Frequency of an Element. We can find the frequency of an element using upper_bound() - lower_bound().

ğŸ”¹ Summary
            Function	                  |                Returns
lower_bound(v.begin(), v.end(), X)        |           First element â‰¥ X
upper_bound(v.begin(), v.end(), X)	      |           First element > X
upper_bound() - lower_bound()	          |               Count of X

<-- Queue -->

Que â“Explain different types of queues available in C++.
1. Queue (std::queue)  : #include <queue>
ğŸ”¹FIFO (First In, First Out) data structure.
ğŸ”¹Elements are added at the back (push()) and removed from the front (pop()).

2. Priority Queue (std::priority_queue) : #include <queue>
ğŸ”¹Elements are stored in sorted order (default: max heap, highest element first).
ğŸ”¹Uses a binary heap internally.
ğŸ”¹Example (Max Heap by default):                            priority_queue<int> pq;
ğŸ”¹Min Heap (Smallest element first) using greater<int>:     priority_queue<int, vector<int>, greater<int>> minHeap;

3. Deque (std::deque) : #include <deque>
ğŸ”¹Double-ended queue, allows insertions and deletions at both ends.
ğŸ”¹More flexible than queue, but slightly more overhead. âœ…

<-- Set -->

Que â“How to access set elements ?
1ï¸âƒ£ Access Elements Using Iterators (begin(), end())
ğŸ”¹Example : - 
    set<int> s = {10, 20, 30, 40};
    for (auto it = s.begin(); it != s.end(); it++) {
        cout << *it << " "; 
    }

2ï¸âƒ£ Access Elements Using Range-Based Loop 
ğŸ”¹Example : - 
    for (int x : s) {
        cout << x << " ";
    }

3ï¸âƒ£ Access the First and Last Element
Although set does not support direct indexing ([]), you can get: First element: *s.begin(), Last element: *s.rbegin()
ğŸ”¹Example : - 
    cout << "First: " << *s.begin() << "\n";
    cout << "Last: " << *s.rbegin() << "\n";

4ï¸âƒ£ Access Specific Elements Using find()
If you need to check whether an element exists in the set, use find().
ğŸ”¹Example : - 
    auto it = s.find(20);
    if (it != s.end()) 
        cout << "Found: " << *it;
    else 
        cout << "Not Found";
ğŸ”¹Efficient O(log N) lookup instead of O(N) loop.

âœ… Summary: Best Ways to Access Set Elements
____________Operation_____________|___________________________Method______________________________ 
Traverse all elements	          |          for (int x : s) âœ…
Use iterators	                  |          for (auto it = s.begin(); it != s.end(); it++)
Get first element	              |          *s.begin()
Get last element	              |          *s.rbegin()
Find an element	                  |          s.find(x) != s.end() âœ…
Reverse traversal	              |          for (auto it = s.rbegin(); it != s.rend(); it++)